% This script is used to compare simplex iteration counts for the 
% algorithms with and without perturbations.
%
% The results generated by this scriptis are presented in our paper
% 
% "Active-set prediction for interior point methods"  
%
% Change the value of "Type" will enable yout to do three tests, random, 
% random_degen and netlib.
% 
% 12 Sep 2013
% Yiming Yan
% University of Edinburgh

%% %%%%% %%%%%%% %%%%%%% --- Main Func --- %%%%%%% %%%%%%% %%%%% %%
function testCrossOver2Simplex
clear all;
close all;
clc;

%% Setup
% Determine which set of problems to test on.
% Choose from the following three values:
% random, netlib, random_degen
Type = 'random';   

% Determine which active-set prediction strategy to use.
% In the paper, we mainly show the results of using a constant as threshold
% value ('conservCutoff'). In the last part the paper, we also mentioned
% the use of identification fucntion ('conservIdFunc'). Both strategies have
% been implemented. 
actvPredStrtgy = 'conservCutoff'; % Default value conservCutoff
                                  % Alternative: conservIdFunc
                        
% -------------------------------------------------------------------------

% For random test only
numTestProb = 100;          % Set to 10 for demo. 100 for real test.
seed = 1;                   % Seed for random number generator


% For netlib test only
nameOfProbSet = 'testNetlib.txt'; 

% With perturbations
parameters_per.verbose = 0;
parameters_per.iPer = 1e-02;
parameters_per.mu_cap = 1e-03;
parameters_per.actvPredStrtgy = actvPredStrtgy;
parameters_per.doCrossOver = 1; 

% Without perturbations
parameters_unper.verbose = 0;
parameters_unper.iPer = 0;
parameters_unper.actvPredStrtgy = actvPredStrtgy;
parameters_unper.doCrossOver = 1;

% Options for the plots
options_evalPerf = [];
options_evalPerf.solverNames = {'With perturbations' 'Without perturbations'};
options_evalPerf.fileName = [ 'crossover_to_simplex_test_' Type];
options_evalPerf.logplot = 1;
options_evalPerf.Quiet = 0;
options_evalPerf.isCaptions = 0; 

logFileName = [options_evalPerf.fileName '.log'];

if exist(fullfile(cd, logFileName),'file')
    delete(logFileName);
end

diary(logFileName);
%% Run the test
fprintf('============================ Crossover Tests ============================\n');

% Header: 1    2   3    4   5  6   7  8 
fprintf('%10s & %4s & %4s & %9s & %9s & %9s & %9s & %9s \\\\ \n',...
    'Prob', 'm', 'n', 'mu_per', 'mu_unp', 'iter_ipm', 'splx_per', 'splx_unp');

% Initialize
switch Type
    case 'netlib'
        % read in the name of all test priblems and stoe them in a cell
        prob2test = readProbSet(nameOfProbSet);
        
        % get the number of test problems
        numTestProb = length(prob2test);
        
        %fprintf('Netlib: In total %d problems detected.\n',numTestProb);
        
    case {'random', 'random_degen'}
        rng('default');
        rng(seed);
        prob2test =  strtrim( cellstr( num2str((1:numTestProb)', 'random_%d') ) );
    otherwise
        return;
end

i = 1;

splxIter_per = zeros(numTestProb,1); 
splxIter_unp = splxIter_per;
mu_per = splxIter_per;
mu_unp = splxIter_per;
ipm_iter = splxIter_per;
while i<=numTestProb
    switch Type
         case 'netlib'
            % load test problems
            load(prob2test{i});
            [A,b,c,FEASIBLE]=myPreprocess(A,b,c,lbounds,ubounds,BIG);
            
        case 'random'
            [A,b,c] = generateRandomProb;
            
        case 'random_degen'
            [A, b, c] = generateDegenProb;
    end
    
    % Solve the problem using pipm
    per = pipm(A,b,c,parameters_per); per.solve;
    
    parameters_unper.maxIter = per.getIPMIterCount;
    unper = pipm(A,b,c,parameters_unper); unper.solve;
    
    if per.status.exitflag == 0 && per.getMu > 1e-03 
        Prob = [ prob2test{i} '*' ];
    else
        Prob = prob2test{i};
    end
    
    if per.getSplxIter > unper.getSplxIter
        Prob = [ '\textbf{' Prob '}'];
    end
    % Iter:  1        2   3       4      5      6      7      8
    fprintf('%10s & %4d & %4d & %9.2e & %9.2e & %9d & %9d & %9d \\\\ \n',...
        Prob, per.prob.m, per.prob.n, per.getMu, unper.getMu,...
        per.getIPMIterCount, per.getSplxIter, unper.getSplxIter);
    
    splxIter_per(i) = per.getSplxIter;
    splxIter_unp(i) = unper.getSplxIter;
    mu_per(i)       = per.getMu;
    mu_unp(i)       = unper.getMu;
    ipm_iter(i)     = per.getIPMIterCount;
    
    % Increment counter
    i = i+1;
end
fprintf('---------------------------------------------------------------------\n');
tmp_splxIter_per = splxIter_per; tmp_splxIter_unp = splxIter_unp;
tmp_splxIter_per(isnan(tmp_splxIter_per)) = [];
tmp_splxIter_unp(isnan(tmp_splxIter_unp)) = [];
% The average value of splxIter_per and _unp are calculated after removed
% failures.
fprintf('%10s & %4s & %4s & %9.2e & %9.2e & %9d & %9d & %9d\n',...
        'Average:', ' ', ' ', mean(mu_per), mean(mu_unp),...
        round(mean(ipm_iter)), round(mean(tmp_splxIter_per)), round(mean(tmp_splxIter_unp)));
% Plot relative performance chart
T = [splxIter_per splxIter_unp];

% Remove problems that cannot be solved by two 
indx = find(sum(isnan(T),2) > 1);
T(indx,:) = [];

fprintf('# of Probs removed: %d\n', length(indx));
fprintf('Problems removed: \n');
fprintf('%s\n',prob2test{indx})

profiles = evalPerformance(T,options_evalPerf);
% profiles.performaceProfile;
profiles.relativePerformacne;

diary off;
end

%% %%%%% %%%%%%% %%%%%%% --- Main Func End --- %%%%%%% %%%%%%% %%%%% %% 

